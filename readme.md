# Основаная задача
Есть кусочно заданная линейная функция. Функция задаётся точками (x,y), которые соединяются прямыми. Необходимо получать значение этой функции при определённом значении x. Так же оценить сложность алгоритма вычисления значения функции в нотации О-большое. Реализация на любом удобном языке, без использования библиотек. 
Пример использования реализации:

Эта кусочно линейная функция заданная двумя точками
Точки с одинаковым х переписывают друг друга
Входящие точки: x=0,y=100 и x=10,y=122

```python
# Эта кусочно линейная функция заданная двумя точками
# Точки с одинаковым х переписывают друг друга
# Входящие точки: x=0,y=100 и x=10,y=122

F = piecewise_func(0,100)(10,122) #.. и т.д

# Добавим еще одну точку, к примеру, x=30, y=0

F = F(30, 0)

# Вычислим значение от x = 5
F.y(5) 
# Результат: y = 111
```

# Дополнительная задача

Реализовать функцию получения таблицы. Необходимо получить таблицу вида:
```
--------------------
| x1 | x2 | a | b |
--------------------
|    |    |   |   |
--------------------
|    |    |   |   |
```
Где x1, x2 - это границы интервала, a и b - коэффициенты линейной функции.

# Описание решения

Для решения данной задачи я создал класс piecewise_func, который
инициализирует первую пару точек (x,y). При многократном вызове 
экземпляра класса можно 
добавлять новые точки. Т.к. для хранения пар точек я использую словарь, 
в котором в качестве ключа
ипользуется координата x, точки с одинаковыми координатами будут 
перезаписаны.
```python
class piecewise_func:

    def __init__(self, x, y):

        self._points = dict()
        self._points[x] = y

    def __call__(self, x, y):
        self._points[x] = y
        return self
```
Точки заносятся в класс, теперь нужно обработать их и решить задачу.
Сначала нужно определить интервал, на котором находится x. 
Для этого я написал метод
get_interval:
```python
def _find_interval(self, x):
    x_points = [xp for xp in self._points]
    left, right = min(x_points), max(x_points)
    for seek_x in x_points:
        if seek_x <= x:
            left = max(left, seek_x)
        elif seek_x > x:
            right = min(right, seek_x)
    return left, right
```
Здесь мы проходим по все точкам x, выполняется за O(n).  
Далее можно непосредственно найти уравнение прямой, проходящей 
через точки, которые лежат на границах найденного интервала:
```python
def y(self, x):
    x1, x2 = self._find_interval(x)
    y1, y2 = self._points[x1], self._points[x2]
    if x1 == x2:
        return self._points[x1]
    return (x-x1)*(y2-y1)/(x2-x1) + y1
```
Здесь я использую уравнение прямой, проходящей через две точки. 
Вычисляется за O(1). Если интервал нулевой, то искомое значение 
лежит на границе интервалов.  
Значение y я получаю в словаре за О(1), значение y на интервале 
вычисляется за О(1), а интервал ищется за О(n). Таким образом, 
сложность данного алгоритма О(n)  
Для выполнения дополнительного задания я написал следующий метод:
```python
def table(self):
    x_sorted = sorted([xp for xp in self._points])
    print('--------------------------')
    print('|  x1  |  x2  |  a  |  b  |')
    for i in range(len(x_sorted)-1):
        x1, x2 = x_sorted[i], x_sorted[i+1]
        y1, y2 = self._points[x1], self._points[x2]
        a = -(y2-y1)/(x1-x2)
        b = -(x2*y1 - x1*y2)/(x1-x2)
        print('--------------------------')
        print(f'|  {x1}  |  {x2}  |  {a}  |  {b}  |')
```
Здесь я вычисляю коэффициенты a и b по той же, только преобразованной, 
формуле, что и в методе выше.  
Задача решена. Спасибо за интересное задание.